<script type="text/javascript">
  const MUTOR_alib = {
      draw_waveform : (buffer, canvas) =>
      {
	  const samps = buffer.getChannelData(0);
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  let samps_per_pixel = Math.floor(samps.length / width);
	  ctx.clearRect(0, 0, width, height);
	  ctx.fillStyle = "#000000";
	  ctx.fillRect(0, 0, width, height);
	  ctx.strokeStyle = "#FFFFFF";
	  ctx.moveTo(0, height / 2);
	  for(x = 0; x < width; x++){
	      let y = 0;//, yy = 0;
	      for(i = 0; i < samps_per_pixel; i++){
		  //yy += samps[i + (samps_per_pixel * x)];
		  y += Math.pow(samps[i + (samps_per_pixel * x)], 2.);
	      }
	      y = Math.sqrt(y / samps_per_pixel);
	      if(x % 2){
		  y *= -1;
	      }
	      y = y * (height / 2.) + (height / 2.);
	      ctx.lineTo(x, y);
	  }
	  ctx.stroke();
      },
      draw_meter : (meter, canvas, color) =>
      {
	  const v = 1 - meter.getValue();
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const vc = v * (height);
	  ctx.clearRect(0, 0, width, height);
	  ctx.fillStyle = color;
	  ctx.beginPath();
	  ctx.fillRect(0, vc, width, height);
	  ctx.stroke();
      },
      draw_playhead : (player, progress, canvas, color) =>
      {
	  const v = progress;
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const vc = v * (width);
	  ctx.clearRect(0, 0, width, height);
	  ctx.strokeStyle = "#FFFFFF";
	  ctx.beginPath();
	  ctx.moveTo(vc, 0);
	  ctx.lineTo(vc, height);
	  ctx.stroke();
      },
      draw_spectroscope : (fft, gain, canvas, color) =>
      {
	  let spec = fft.getValue();
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const g = parseFloat(gain);
	  let samps_per_pixel = Math.floor(fft.size / width);
	  if(samps_per_pixel == 0){
	      samps_per_pixel = 1;
	  }
	  ctx.clearRect(0, 0, width, height);
	  ctx.fillStyle = "#000000";
	  ctx.fillRect(0, 0, width, height);
	  //ctx.strokeStyle = "#FFFFFF";
	  ctx.fillStyle = "#FFFFFF";
	  ctx.beginPath();
	  ctx.moveTo(0, height);
	  for(x = 0; x < fft.size; x++){
	      ctx.lineTo(x, height - (spec[x] * g));
	  }
	  //ctx.stroke();
	  ctx.closePath();
	  ctx.fill();
      },
      draw_sonogram : (fft, gain, canvas, color) =>
      {
	  let spec = fft.getValue();
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const g = parseFloat(gain);
	  // shift everything to the left by one col of pixels	  
	  let imageData = ctx.getImageData(1, 0, width - 1, height);
	  ctx.putImageData(imageData, 0, 0);

	  if(height < fft.size){
	      let samps_per_pixel = Math.floor(fft.size / height);
	      for(i = 0; i < height; i++){
		  let y = 0;
		  for(j = 0; j < samps_per_pixel; j++){
		      y += spec[j + (i * samps_per_pixel)];
		  }
		  y /= samps_per_pixel;
		  ctx.fillStyle = `hsl(
        	  	${Math.floor(y * g * 360.)},
        	  	${Math.floor(y * g * 100.)}%,
	          	${Math.floor(y * g * 100.)}%)`;
		  ctx.fillRect(width - 1, height - i - 1, 1, 1);
	      }
	  }else{
	      let pixels_per_samp = Math.floor(height / fft.size);
	      for(i = 0; i < fft.size; i++){
		  let y = spec[i];
		  ctx.fillStyle = `hsl(
        	  	${Math.floor(y * g * 360.)},
        	  	${Math.floor(y * g * 100.)}%,
	          	${Math.floor(y * g * 100.)}%)`;
		  ctx.fillRect(width - 1, height - (i * pixels_per_samp) - 1, 1, pixels_per_samp);
	      }
	  }
      },
  };
</script>
