<script type="text/javascript">
  const MUTOR_alib = {
      draw_waveform : (buffer, canvas) =>
      {
	  const samps = buffer.getChannelData(0);
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  let samps_per_pixel = Math.floor(samps.length / width);
	  ctx.clearRect(0, 0, width, height);
	  ctx.fillStyle = "#000000";
	  ctx.fillRect(0, 0, width, height);
	  ctx.strokeStyle = "#FFFFFF";
	  ctx.moveTo(0, height / 2);
	  for(x = 0; x < width; x++){
	      let y = 0;//, yy = 0;
	      for(i = 0; i < samps_per_pixel; i++){
		  //yy += samps[i + (samps_per_pixel * x)];
		  y += Math.pow(samps[i + (samps_per_pixel * x)], 2.);
	      }
	      y = Math.sqrt(y / samps_per_pixel);
	      if(x % 2){
		  y *= -1;
	      }
	      y = y * (height / 2.) + (height / 2.);
	      ctx.lineTo(x, y);
	  }
	  ctx.stroke();
      },
      draw_meter : (meter, canvas, color) =>
      {
	  const v = 1 - meter.getValue();
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const vc = v * (height);
	  ctx.clearRect(0, 0, width, height);
	  ctx.fillStyle = color;
	  ctx.beginPath();
	  ctx.fillRect(0, vc, width, height);
	  ctx.stroke();
      },
      draw_playhead : (player, progress, canvas, color) =>
      {
	  const v = progress;
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const vc = v * (width);
	  ctx.clearRect(0, 0, width, height);
	  ctx.strokeStyle = "#FFFFFF";
	  ctx.beginPath();
	  ctx.moveTo(vc, 0);
	  ctx.lineTo(vc, height);
	  ctx.stroke();
      },
      draw_spectroscope : (fft, gain, canvas, color) =>
      {
	  let spec = fft.getValue();
	  let c = canvas;
	  let ctx = c.getContext("2d");
	  const width = parseFloat(c.getAttribute("width"));
	  const height = parseFloat(c.getAttribute("height"));
	  const g = parseFloat(gain);
	  ctx.clearRect(0, 0, width, height);
	  ctx.fillStyle = "#000000";
	  ctx.fillRect(0, 0, width, height);
	  ctx.fillStyle = "#FFFFFF";
	  ctx.beginPath();
	  ctx.moveTo(0, height);
	  if(width < fft.size){
	      let samps_per_pixel = Math.floor(fft.size / width);
	      for(i = 0; i < width; i++){
		  let y = 0;
		  for(j = 0; j < samps_per_pixel; j++){
		      y += spec[j + (i * samps_per_pixel)]
		  }
		  y /= samps_per_pixel;
		  ctx.lineTo(i, height - (y * g));
	      }
	  }else{
	      let pixels_per_samp = Math.floor(width / fft.size);
	      for(i = 0; i < fft.size; i++){
		  let y = spec[i];
		  ctx.lineTo(i * pixels_per_samp, y * -1);//height - (y * g));
	      }
	  }
	  ctx.closePath();
	  ctx.fill();
      },
	draw_sonogram : (fft, gain, canvas, color) =>
	{
	    let spec = fft.getValue();
	    let c = canvas;
	    let ctx = c.getContext("2d");
	    const width = parseFloat(c.getAttribute("width"));
	    const height = parseFloat(c.getAttribute("height"));
	    const g = parseFloat(gain);
	    // shift everything to the left by one col of pixels	  
	    let imageData = ctx.getImageData(1, 0, width - 1, height);
	    ctx.putImageData(imageData, 0, 0);

	    if(height < fft.size){
		let samps_per_pixel = Math.floor(fft.size / height);
		for(i = 0; i < height; i++){
		    let y = 0;
		    for(j = 0; j < samps_per_pixel; j++){
			y += spec[j + (i * samps_per_pixel)];
		    }
		    y /= samps_per_pixel;
		    ctx.fillStyle = `hsl(
        	  	${Math.floor(y * g * 360.)},
        	  	${Math.floor(y * g * 100.)}%,
	          	${Math.floor(y * g * 100.)}%)`;
		    ctx.fillRect(width - 1, height - i - 1, 1, 1);
		}
	    }else{
		let pixels_per_samp = Math.floor(height / fft.size);
		for(i = 0; i < fft.size; i++){
		    let y = spec[i];
		    ctx.fillStyle = `hsl(
        	  	${Math.floor(y * g * 360.)},
        	  	${Math.floor(y * g * 100.)}%,
	          	${Math.floor(y * g * 100.)}%)`;
		    ctx.fillRect(width - 1, height - (i * pixels_per_samp) - 1, 1, pixels_per_samp);
		}
	    }
	},
	draw_scope : (analyser, gain, samps_per_pixel, lasty, canvas, color) =>
	{
	    let sv = analyser.getValue();
	    const svs = analyser.size;
	    let c = canvas;
	    let ctx = c.getContext("2d");
	    const width = parseFloat(c.getAttribute("width"));
	    const height = parseFloat(c.getAttribute("height"));
	    const g = parseFloat(gain);
	    if(samps_per_pixel < 1){
		samps_per_pixel = 1;
	    }
	    if(samps_per_pixel > svs){
		samps_per_pixel = svs;
	    }

	    const pix_to_draw = (svs / samps_per_pixel);
	    //console.log("svs = " + svs + " samps_per_pixel = " + samps_per_pixel + " pix_to_draw = " + pix_to_draw);
	    // shift everything to the left by one col of pixels
	    let imageData;
	    if(pix_to_draw < width){
	    	imageData = ctx.getImageData(pix_to_draw - 1, 0, (width - 1) - pix_to_draw, height);
	    }
	    ctx.clearRect(0, 0, width, height);
	    ctx.fillStyle = "#000000";
	    ctx.fillRect(0, 0, width, height);
	    if(pix_to_draw < width){
	    	ctx.putImageData(imageData, 0, 0);
	    }
	    
	    // ctx.clearRect(0, 0, width, height);
	    // ctx.fillStyle = "#000000";
	    // ctx.fillRect(0, 0, width, height);
	    ctx.strokeStyle = "#FFFFFF";
	    ctx.beginPath();
	    let x = (width - 1) - pix_to_draw;
	    let y = 0;
	    ctx.moveTo(x - 1, lasty);
	    for(i = 0; i < pix_to_draw; i++){
		// y = 0;
		// for(j = 0; j < samps_per_pixel; j++){
		//     y += sv[i + (j * samps_per_pixel)];
		// }
		// y /= samps_per_pixel;
		y = sv[i * samps_per_pixel];
		y = ((-y + 1.) / 2.) * height;
		ctx.lineTo(x, y);
		++x;
	    }
	    
	    //ctx.closePath();
	    //ctx.fill();
	    ctx.stroke();
	    return y;
	},
	};
</script>
